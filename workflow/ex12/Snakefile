# >>>> Snakefile 'README' >>>>
# 1. Observe subtensor a priori
# 2. Embed both the observations and the induced remnants
# 3. Calculate convex combination distances
# 4. Reconstruction from scores based on distances
# <<<< Snakefile 'README' <<<<
# ======================================================================
# ======== IMPORTS/PYTHON PRE-CONFIG ==========
from datetime import datetime
from itertools import product

# ======== CONFIG =========
configfile: "config.yaml"
config = config["synthetic"]

# Aliases
_meta = config["meta"]
_network = config["network"]
_params = config["experiment"]["params"]
_hyperparams = config["experiment"]["hyperparams"]
_pathing = config["workflow"]["pathing"]
_datafiles = config["workflow"]["datafiles"]

# Globals
DATE = datetime.today().strftime("%Y%m%d")
ROOT = "../.."
REPETITIONS = range(1, int(_params["repetitions"]))

# =========== WORKFLOW ===========
# ----- All rule ----
rule all:
    input:
        # Dataframe
        _datafiles["result"]["dataframe"].format(
            dir=_pathing["result"]["dataframe"].format(root=ROOT),
            project_id=_meta["project_id"], current_version=_meta["current_version"],
            researcher=_meta["researcher"],
            date=DATE
        ),
        # DAG
        _datafiles["result"]["dag"].format(
            dir=_pathing["result"]["reports"].format(root=ROOT),
            project_id=_meta["project_id"], current_version=_meta["current_version"],
            researcher=_meta["researcher"],
            date=DATE
        )


# ----- Analysis rules -----
# - Meta analysis -
rule meta_report:
    output:
        _datafiles["result"]["report"].format(
            dir=_pathing["result"]["reports"].format(root=ROOT),
            project_id=_meta["project_id"], current_version=_meta["current_version"],
            researcher=_meta["researcher"],
            date=DATE
        )
    shell:
        "snakemake --report {output}"

rule meta_dag:
    output:
        _datafiles["result"]["dag"].format(
            dir=_pathing["result"]["reports"].format(root=ROOT),
            project_id=_meta["project_id"], current_version=_meta["current_version"],
            researcher=_meta["researcher"],
            date=DATE
        )
    shell:
        "snakemake --rulegraph | dot -Tsvg > {output}"

# - Data analysis -
rule generate_plots:
    input:
        dataframe = _datafiles["result"]["dataframe"].format(
            dir=_pathing["result"]["dataframe"].format(root=ROOT),
            project_id=_meta["project_id"], current_version=_meta["current_version"],
            researcher=_meta["researcher"],
            date=DATE
        )
    output:   # * CAN WE AUTO GENERATE MORE? :/
        scatter = _datafiles["result"]["figures"]["scatter"].format(
            dir=_pathing["result"]["figures"].format(root=ROOT),
            project_id=_meta["project_id"], current_version=_meta["current_version"],
            researcher=_meta["researcher"],
            date=DATE
        )
    script:
        _pathing["scripts"] + "generate_plots.py"

# - Data aggregation -
rule aggregate_records:
    input:
        expand(
            _datafiles["output"]["record"].format(dir=_pathing["output"]["raw"].format(root=ROOT)),
            avg_k=_network["avg_k"],
            gamma=_network["gamma"],
            mu=_network["mu"],
            metric=_params["metrics"],
            pfi=_params["pfis"],
            rep=REPETITIONS,
        )
    output:
        _datafiles["result"]["dataframe"].format(
            dir=_pathing["result"]["dataframe"].format(root=ROOT),
            project_id=_meta["project_id"], current_version=_meta["current_version"],
            researcher=_meta["researcher"],
            date=DATE
        )
    script:
        _pathing["scripts"] + "aggregate_records.py"

# rule aggregate_records_real:
#     input:
#         [
#             [
#                 expand(
#                     _datafiles["output"]["record"].format(dir=_pathing["output"]["raw"].format(root=ROOT)),
#                     system=system_,
#                     alpha=alpha,
#                     beta=beta,
#                     dimension=_params["dimensions"],
#                     metric=_params["metrics"],
#                     pfi=_params["pfis"],
#                     rep=REPETITIONS,
#                 )
#                 # * Remove symmetric and trivial duplexes
#                 for alpha in _network[system_]["layers"] for beta in _network[system_]["layers"] if alpha < beta
#             ]
#             for system_ in _network.keys()
#         ]
#     output:
#         _datafiles["result"]["dataframe"].format(
#             dir=_pathing["result"]["dataframe"].format(root=ROOT),
#             project_id=_meta["project_id"], current_version=_meta["current_version"],
#             researcher=_meta["researcher"],
#             date=DATE
#         )
#     script:
#         _pathing["scripts"] + "aggregate_records.py"


rule measure_performance:
    input:
        reconstruction = _datafiles["output"]["reconstruction"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        )
    output:
        temp(_datafiles["output"]["record"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        ))
    params:
        metric = "{metric}"
    script:
        _pathing["scripts"] + "measure_performance.py"


# ----- Computation rules -----
rule observe_subtensor:
    input:
        multiplex = _datafiles["input"]["duplex"].format(
            dir=_pathing["input"]["preprocessed"].format(root=ROOT)
        )
    output:
        temp(_datafiles["output"]["observation"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        ))
    params:
        pfi = "{pfi}",
        rep = "{rep}"
    script:
        _pathing["scripts"] + "observe_subtensor.py"

# rule observe_subtensor_real:
#     input:
#         duplex_edgelist = _datafiles["input"]["duplex"].format(
#             dir=_pathing["input"]["preprocessed"].format(root=ROOT)
#         )
#     output:
#         temp(_datafiles["output"]["observation"].format(
#             dir=_pathing["output"]["raw"].format(root=ROOT)
#         ))
#     params:
#         alpha = "{alpha}",
#         beta = "{beta}",
#         pfi = "{pfi}",
#         rep = "{rep}"
#     script:
#         _pathing["scripts"] + "observe_subtensor_real.py"

rule embed_remnant:
    input:
        _datafiles["output"]["observation"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        )
    output:
        pipe(_datafiles["output"]["vectors"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        ))
    params:
        hyperparams = config["experiment"]["hyperparams"]
    script:
        _pathing["scripts"] + "embed_remnant.py"

rule calculate_distances:
    input:
        vectors = _datafiles["output"]["vectors"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        ),
        observation = _datafiles["output"]["observation"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        )
    output:
        temp(_datafiles["output"]["distances"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        ))
    script:
        _pathing["scripts"] + "calculate_distances.py"


rule reconstruct_tensor:
    input:
        distances = _datafiles["output"]["distances"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        ),
        observation = _datafiles["output"]["observation"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        )
    output:
        _datafiles["output"]["reconstruction"].format(
            dir=_pathing["output"]["raw"].format(root=ROOT)
        )
    params:
        metric = "{metric}"
    script:
        _pathing["scripts"] + "reconstruct_tensor.py"
